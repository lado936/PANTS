#' Pathway analysis via network smoothing
#' 
#' This is the main function of the \code{PANTS} package, which implements the Pants algorithm for group contrasts.
#' 
#' @param object A matrix-like data object containing log-ratios or log-expression values for a
#' series of samples, with rows corresponding to features and columns to samples.
#' @param phenotype.v A vector of phenotypes of strings the same length as number of samples in \code{object}.
#' If the vector is named, the names must match the column names of \code{object}.
#' @param contrast.v A named vector of constrasts. The constrasts must refer to the phenotypes
#' in \code{phenotype.v}. Their order defines the order they are passed to \code{score_fcn}.
#' @param Gmat Binary feature by pathway inclusion matrix, indicating which features are in which pathways.
#' @param annot A data frame of feature annotation.
#' @param ker Laplacian kernel matrix.
#' @param score_fcn A function that transforms the t-statistics from the contrasts. \code{identity} is 
#' the trivial identity function returning its argument. Its input must be a vector of same 
#' length as number of elements in \code{contrast.v}. Its output must be a scalar.
#' @param nperm Number of permutations to perform to evaluate significance of pathways.
#' @param ret.null.mats If TRUE, return matrices with null distributions for features and pathwaysle
#' @param alternative A character string specifying the alternative hypothesis.
#' @param min.size Pathways with fewer than \code{min.size} measured features in \code{object} are filtered out.
#' @param ncores Number of cores to use for parallel computing. You can detect how many are available for your system
#' using \code{\link[parallel]{detectCores}}.
#' @param name Name for the folder and Excel file that get written. Set to \code{NA} to avoid writing output.
#' @param n.toptabs number of pathway toptables to write to CSV and link to from Excel.
#' @details Scores for features in the kernel but not in the data are assigned a z-score of zero by default for sparsity.
#' Scores for features and pathways are compared to null scores, which are generated by permuting the columns of 
#' \code{object} and rerunning the algorithm.
#' 
#' For \code{\link[parallel]{makeCluster}}, the cluster \code{type} depends on the OS, which is tested in the body
#' of the function using \code{.Platform$OS.type}.
#' 
#' If \code{!is.na(name)}, an Excel file gets written out with links to toptable CSVs, containing the statistics of features in
#' the pathway. If \code{ker} is used, pathways may be affected via smoothing by features outside the pathway. These can be seen
#' with \code{\link[PANTS]{plot_pwy}}.
#'  
#' @return List of at least two dataframes:
#' \describe{
#'    \item{pwy.stats}{A dataframe with columns 
#'    \describe{
#'    \item{nfeatures}{number of features in the pathway} 
#'    \item{feat.score.avg}{sum of smoothed scores of the pathway's features / \code{nfeatures}. This score is compared
#'    to scores in permutations. Only included if \code{ret.null.mats==TRUE}.}
#'    \item{z}{pathway permutation z-score (larger is more significant)}
#'    \item{p}{pathway permutation p-value} 
#'    \item{FDR}{pathway FDR calculated from p-values with \code{p.adjust(p, method='BH')}}
#'    }}
#'    \item{feature.stats}{A dataframe with columns
#'    \describe{
#'    \item{score}{feature's score from applying \code{score_fcn} in \code{\link{score_features}}}
#'    \item{z}{feature z-score (larger is more significant) relative to this feature's scores in permutation 
#'    (without smoothing)} 
#'    \item{p}{feature's permutation p-value} 
#'    \item{FDR}{feature's FDR from permutation \code{p}}
#'    }}
#'    And if \code{ret.null.mats} is TRUE:
#'    \item{null.feature.mat}{Matrix with features as rows and permutations as columns, where each element represents
#'    the score of that feature in that permutation}
#'    \item{null.pwy.mat}{Matrix with pathways as rows and permutations as columns, where each element represents
#'    the score of that pathway in that permutation}
#'  }
#' @export

pants <- function(object, phenotype.v, contrast.v, Gmat, annot, ker=NULL, score_fcn=identity, nperm=10^4-1, ret.null.mats=FALSE, 
                  alternative=c("two.sided", "less", "greater"), min.size=0, ncores=1, name=NA, 
                  n.toptabs=Inf, seed=0){
  if (is.null(ker)){
    ker <- diag_kernel(object=object, Gmat=Gmat)
  }
  stopifnot(length(intersect(rownames(ker), rownames(object)))>0, any(rownames(Gmat) %in% colnames(ker)), any(rownames(Gmat) %in% rownames(annot)), 
            colnames(object)==names(phenotype.v))
  alternative <- match.arg(alternative)
  
  zeallot::`%<-%`(c(Gmat, nfeats.per.pwy), subset_gmat(object=object, Gmat=Gmat, min.size=min.size))

  score.v <- score_features(object=object, phenotype.v=phenotype.v, contrast.v=contrast.v, score_fcn=score_fcn)
  
  #feature scores in permutations, 74% dense but later combine with a sparse (empty) matrix
  cl.type <- ifelse(.Platform$OS.type=='windows', "PSOCK", "FORK")
  cl <- parallel::makeCluster(spec=ncores, type=cl.type)
  set.seed(seed)
  perms <- lapply(seq_len(nperm), function(i) sample.int(length(phenotype.v)))
  score.mat <- parallel::parSapply(cl, perms, function(perm){
    #must set permuted names to NULL st limma_contrasts doesn't complain thay they clash with colnames(object)
    pheno.tmp <- stats::setNames(phenotype.v[perm], nm=NULL)
    score_features(object=object, phenotype.v=pheno.tmp, contrast.v=contrast.v, score_fcn=score_fcn)
  })
  dimnames(score.mat) <- list(rownames(object), paste0('perm', 1:nperm))
  parallel::stopCluster(cl=cl)
  
  #could use zeallot, but would still need temporary score.mat.comb
  mm <- match_mats(score.mat = cbind(v=score.v, score.mat), ker=ker, Gmat=Gmat)
  score.mat <- mm$score.mat[,-1]; score.v <- mm$score.mat[,1]; ker <- mm$ker; Gmat <- mm$Gmat
  rm(mm) #to save memory
  
  ##feature p-values (for plotting)
  #features in object & in kernel
  feature.stats <- data.frame(score = score.v, matrix(NA, nrow=length(score.v), ncol=3, 
                                                      dimnames=list(rownames(score.mat), c("z", "p", "FDR"))))
  #need to coerce score.mat to matrix to prevent rowSums error
  feature.stats[,c("z", "p")] <- p_ecdf(eval.v=score.v, score.mat = as.matrix(score.mat), alternative = alternative)
  feature.stats[,"FDR"] <- stats::p.adjust(feature.stats[,"p"], method="BH")

  ##need to compare to pwys, sometimes runs out of memory
  pwy.v <- (score.v %*% ker %*% Gmat)[1,]
  pwy.mat <- as.matrix(Matrix::t(Matrix::crossprod(score.mat, ker) %*% Gmat))

  pwy.stats <- data.frame(nfeatures=nfeats.per.pwy, feat.score.avg=pwy.v/nfeats.per.pwy, z=NA, p=NA)
  rownames(pwy.stats) <- colnames(Gmat)
  pwy.stats[,c("z", "p")] <- p_ecdf(eval.v=pwy.v, score.mat=pwy.mat, alternative = alternative)
  pwy.stats$FDR <- stats::p.adjust(pwy.stats$p, method='BH')
  pwy.stats <- pwy.stats[order(pwy.stats$p, -pwy.stats$feat.score.avg),]

  #write xlsx file with links
  #tested this manually once
  if (!is.na(name)){
    index <- lapply(colnames(Gmat), function(pwy) rownames(Gmat)[Gmat[,pwy] > 0])
    names(index) <- colnames(Gmat)
    feature.stats2 <- data.frame(signif(feature.stats, 3), annot[rownames(feature.stats), ])
    ezlimma::write_linked_xlsx(name=name, fun="pants", res=pwy.stats, index=index, stats.tab=feature.stats2, n.toptabs=n.toptabs)
  }
  
  # return res
  res <- list(pwy.stats=pwy.stats, feature.stats=feature.stats)
  if (ret.null.mats){
    res$null.feature.mat <- as.matrix(score.mat)
    res$null.pwy.mat <- as.matrix(pwy.mat)
  } else {
    #only include "feat.score.avg" if ret.null.mats
    res$pwy.stats <- res$pwy.stats[,setdiff(colnames(res$pwy.stats), "feat.score.avg")]
  }
  
  return(res)
}