#' Pathway Analysis via network smoothing (Pants) testing mediation with Hitman
#' 
#' Pants with \code{\link[ezlimma]{hitman}} to test mediation of features (i.e. an analyte such as a gene, protein, 
#' or metabolite) in a pathway or those connected to the pathway in an interaction network. A workflow is described in
#' the vignette; instructions to view the vignette are in the README.
#' 
#' @param exposure A numeric vector or matrix of exposures.
#' @param covariates Numeric vector or matrix of covariates.
#' @param nperm Number of sample permutations of \code{object} to evaluate significance of pathways.
#' @inheritParams pants
#' @inheritParams ezlimma::limma_contrasts
#' @inheritParams ezlimma::limma_cor
#' @inheritParams ezlimma::roast_contrasts
#' @details  
#' In \code{\link{pants}}, samples in \code{phenotype} are permuted, since this properly permutes the \code{object} to 
#' \code{phenotype} mapping; \code{object} could be equivalently permuted. Here, because \code{object} is tested for 
#' its association to both \code{phenotype} and \code{exposure}, samples of \code{object} are permuted.
#' 
#' Scores for features in the kernel but not in the data are assigned a z-score of zero by default for sparsity.
#' Scores for features and pathways are compared to null scores, which are generated by permuting the columns of 
#' \code{object} and rerunning the algorithm. These are the stats returned in \code{feature.stats}. However, \code{pants}
#' accepts \code{feat.tab} with statistics from \code{ezlimma} per-feature analysis for the Excel file to link to;
#' these may be more precise, since they don't rely on a limited number of permutations. If \code{feat.tab} is \code{NULL},
#' the Excel file links to tables derived from \code{feature.stats}.

#' For \code{\link[parallel]{makeCluster}}, the cluster \code{type} depends on the OS, which is tested in the body
#' of the function using \code{.Platform$OS.type}.
#' 
#' If \code{!is.na(name)}, an Excel file with "_pants_hitman.xlsx" appended to \code{name} gets written out with links to CSVs 
#' containing the statistics and annotation of features most affecting the pathway's score. The statistics and annotation
#' are from \code{feat.tab}, which is usually calculated with \code{\link[ezlimma]{hitman}}. Additionally, the CSVs contain
#' whether each feature is in the pathway, and an \code{impact} column describing the impact of each feature on the pathway's
#' score. Since pathway significance is calculated in \code{pants_hitman}, \code{impact} uses the feature statistics 
#' calculated in \code{pants_hitman} by comparing to permutation. The feature statistics from \code{\link[ezlimma]{hitman}}
#' and those from \code{pants_hitman} are nearly identical, though; the main difference is that \code{pants_hitman} 
#' feature significances are limited by the number of permutations, so they flatten near the extreme. The features with the
#' largest magnitude impact score are those most affecting the pathway's score, and can be visualized with 
#' \code{\link[PANTS]{plot_pwy}}. Features with positive impact increase a pathway's score, whereas those with negative 
#' impact decrease it.
#' 
#' @return List of at least two data frames:
#' \describe{
#'    \item{\code{pwy.stats}}{A data frame with columns 
#'    \describe{
#'    \item{\code{nfeatures}}{number of features in the pathway}
#'    \item{\code{z}}{pathway permutation z-score (larger is more significant)}
#'    \item{\code{p}}{pathway permutation p-value} 
#'    \item{\code{FDR}}{pathway FDR calculated from p-values with \code{p.adjust(p, method='BH')}}
#'    }}
#'    \item{\code{feature.stats}}{A data frame with columns
#'    \describe{
#'    \item{\code{score}}{feature's score, which is p-value from \code{\link[ezlimma]{hitman}} transformed into z-score 
#'    (larger is more significant)}
#'    \item{\code{z}}{feature z-score (larger is more significant) relative to this feature's scores in permutation 
#'    without smoothing. This should be similar to \code{score} if the permutation null distribution matches the 
#'    theoretical null distribution.} 
#'    \item{\code{p}}{feature's permutation p-value} 
#'    \item{\code{FDR}}{feature's FDR from permutation \code{p}}
#'    }}
#'    And if \code{ret.null.mats} is TRUE:
#'    \item{\code{null.feature.mat}}{Matrix with features as rows and permutations as columns, where each element represents
#'    the score of that feature in that permutation}
#'    \item{\code{null.pwy.mat}}{Matrix with pathways as rows and permutations as columns, where each element represents
#'    the score of that pathway in that permutation}
#'    \item{\code{sample.perms}}{Matrix with samples as rows and permutations as columns, where each element represents
#'    the index of the sample simulated to represent the sample in the row in that permutation}
#'  }
#' @export

pants_hitman <- function(object, exposure, phenotype, Gmat, covariates=NULL, ker=NULL, feat.tab=NULL, ntop=25, nperm=10^4-1, 
                         ret.null.mats=FALSE, min.nfeats=3, ncores=1, name=NA, seed=0){
  if (is.null(ker)){
    ker <- diag_kernel(object=object, Gmat=Gmat)
  }
  stopifnot(length(intersect(rownames(ker), rownames(object))) > 0, any(rownames(Gmat) %in% colnames(ker)), 
            ncol(object)==length(phenotype), ncol(object)==nrow(as.matrix(exposure)), colnames(object)==names(phenotype))
  if (ncol(as.matrix(exposure))==1){
    stopifnot(colnames(object)==names(exposure))
  } else {
    stopifnot(colnames(object)==rownames(exposure))
  }
  
  zeallot::`%<-%`(c(Gmat, nfeats.per.pwy), subset_gmat(object=object, Gmat=Gmat, min.nfeats=min.nfeats))
  
  hm <- ezlimma::hitman(E=exposure, M=object, Y=phenotype, covariates=covariates)
  # transform to one-sided z-score
  hm.zscore.v <- stats::qnorm(p=hm[rownames(object), "EMY.p"], lower.tail = FALSE)
  
  # feature scores in permutations
  cl.type <- ifelse(.Platform$OS.type=="windows", "PSOCK", "FORK")
  cl <- parallel::makeCluster(spec=ncores, type=cl.type)
  set.seed(seed)
  perms <- lapply(seq_len(nperm), function(i) sample.int(ncol(object)))
  hm.zscore.mat <- parallel::parSapply(cl, perms, function(perm){
    # permute object
    # must set permuted names to NULL st limma_contrasts doesn't complain that they clash with colnames(object)
    object.tmp <- object[,perm]
    # to avoid names error in stopifnot
    colnames(object.tmp) <- colnames(object)
    # permuted hm result
    hm.tmp <- ezlimma::hitman(E=exposure, M=object.tmp, Y=phenotype, covariates=covariates)
    # return z-scores from permuted object
    stats::qnorm(p=hm.tmp[rownames(object), "EMY.p"], lower.tail = FALSE)
  })
  dimnames(hm.zscore.mat) <- list(rownames(object), paste0("perm", 1:nperm))
  parallel::stopCluster(cl=cl)
  
  mm <- match_mats(score.mat = cbind(v=hm.zscore.v, hm.zscore.mat), ker=ker, Gmat=Gmat)
  # 1st column contains non-permuted scores, which matches other objects
  hm.zscore.mat <- mm$score.mat[,-1]; hm.zscore.v <- mm$score.mat[,1]; ker <- mm$ker; Gmat <- mm$Gmat
  rm(mm) #to save memory
  if (any(rownames(hm.zscore.v) != rownames(ker) | rownames(ker) != rownames(Gmat))){
    stop("internal function match_mats failed; please report the error by raising an issue in the github repo.")
  }
  
  # feature p-values (for plotting)
  # features in object & in kernel
  # feature.stats$score != feature.stats$z, because z is from comparing to permutations!
  feature.stats <- data.frame(score = hm.zscore.v, matrix(NA, nrow=length(hm.zscore.v), ncol=3,
                                                      dimnames=list(rownames(hm.zscore.mat), c("z", "p", "FDR"))))
  # need to coerce score.mat to matrix to prevent rowSums error
  feature.stats[,c("z", "p")] <- p_ecdf(eval.v=hm.zscore.v, score.mat = as.matrix(hm.zscore.mat), alternative = "greater")
  feature.stats[,"FDR"] <- stats::p.adjust(feature.stats[,"p"], method="BH")
  # ph=pants hitman; scores from permutations
  ph.zscore.v <- stats::setNames(feature.stats[,"z"], nm=rownames(feature.stats))
  
  # need to compare pwys to permutations, sometimes runs out of memory
  pwy.score.v <- (hm.zscore.v %*% ker %*% Gmat)[1,]
  pwy.score.mat <- as.matrix(Matrix::t(Matrix::crossprod(hm.zscore.mat, ker) %*% Gmat))
  
  # feat.score.avg=pwy.v/nfeats.per.pwy is confusing and not helpful enough to include
  pwy.stats <- data.frame(nfeatures=nfeats.per.pwy, z=NA, p=NA)
  rownames(pwy.stats) <- colnames(Gmat)
  pwy.stats[,c("z", "p")] <- p_ecdf(eval.v=pwy.score.v, score.mat=pwy.score.mat, alternative = "greater")
  pwy.stats$FDR <- stats::p.adjust(pwy.stats$p, method="BH")
  pwy.stats <- pwy.stats[order(pwy.stats$p, -pwy.stats$nfeatures),]
  
  # return res
  res <- list(pwy.stats=pwy.stats, feature.stats=feature.stats)
  if (ret.null.mats){
    res$null.feature.mat <- as.matrix(hm.zscore.mat)
    res$null.pwy.mat <- as.matrix(pwy.score.mat)
    res$sample.perms <- simplify2array(perms)
    dimnames(res$sample.perms) <- list(colnames(object), dimnames(hm.zscore.mat)[[2]])
  }
  
  # write xlsx file with links
  if (!is.na(name)){
    if (is.null(feat.tab)){ feat.tab <- feature.stats }
    stopifnot(is.finite(ph.zscore.v))
    write_pants_xl(zscore.v=ph.zscore.v, pwy.tab=res$pwy.stats, feat.tab=feat.tab, Gmat=Gmat, ker=ker, alternative="greater", 
                   name=paste0(name, "_pants_hitman"), ntop=ntop)
  }
  return(res)
}